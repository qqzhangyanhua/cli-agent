"""
é¡¹ç›®ç®¡ç†å·¥å…· - æ™ºèƒ½é¡¹ç›®å¯åŠ¨å’Œæ‰“åŒ…
æ”¯æŒè‡ªåŠ¨æ£€æµ‹é¡¹ç›®ç±»å‹ã€åˆ†æå‘½ä»¤ã€åå°æ‰§è¡Œå¹¶å¤„ç†ä¾èµ–é—®é¢˜
"""

import json
import os
import re
import subprocess
import signal
import time
from pathlib import Path
from typing import Dict, List, Optional
from langchain_core.tools import Tool

from src.core.agent_config import WORKING_DIRECTORY


class ProjectDetector:
    """é¡¹ç›®ç±»å‹æ£€æµ‹å™¨"""
    
    @staticmethod
    def detect_project_type(work_dir: str = None) -> Dict:
        """
        æ£€æµ‹é¡¹ç›®ç±»å‹
        
        Args:
            work_dir: å·¥ä½œç›®å½•ï¼Œé»˜è®¤ä½¿ç”¨é…ç½®çš„å·¥ä½œç›®å½•
            
        Returns:
            {
                "type": "nodejs" | "python" | "unknown",
                "package_manager": "pnpm" | "npm" | "yarn" | "pip",
                "config_file": "package.json" | "requirements.txt" | ...,
                "scripts": {...},  # ä»… nodejs
                "main_files": [...],  # ä»… python
                "detected_files": [...]  # æ£€æµ‹åˆ°çš„å…³é”®æ–‡ä»¶
            }
        """
        if work_dir is None:
            work_dir = WORKING_DIRECTORY
            
        work_path = Path(work_dir)
        result = {
            "type": "unknown",
            "package_manager": "",
            "config_file": "",
            "scripts": {},
            "main_files": [],
            "detected_files": []
        }
        
        # æ£€æµ‹ Node.js é¡¹ç›®
        package_json = work_path / "package.json"
        if package_json.exists():
            result["type"] = "nodejs"
            result["config_file"] = "package.json"
            result["detected_files"].append("package.json")
            
            try:
                with open(package_json, 'r', encoding='utf-8') as f:
                    package_data = json.load(f)
                    result["scripts"] = package_data.get("scripts", {})
            except Exception as e:
                print(f"[é¡¹ç›®æ£€æµ‹] âš ï¸  è¯»å– package.json å¤±è´¥: {e}")
            
            # æ£€æµ‹åŒ…ç®¡ç†å™¨
            if (work_path / "pnpm-lock.yaml").exists():
                result["package_manager"] = "pnpm"
                result["detected_files"].append("pnpm-lock.yaml")
            elif (work_path / "yarn.lock").exists():
                result["package_manager"] = "yarn"
                result["detected_files"].append("yarn.lock")
            elif (work_path / "package-lock.json").exists():
                result["package_manager"] = "npm"
                result["detected_files"].append("package-lock.json")
            else:
                # é»˜è®¤ä½¿ç”¨ pnpmï¼ˆæ ¹æ®ç”¨æˆ·è§„åˆ™ï¼‰
                result["package_manager"] = "pnpm"
            
            return result
        
        # æ£€æµ‹ Python é¡¹ç›®
        python_indicators = [
            "requirements.txt",
            "pyproject.toml", 
            "setup.py",
            "main.py",
            "app.py",
            "manage.py",
            "run.py"
        ]
        
        python_files_found = []
        main_files = []
        
        for indicator in python_indicators:
            file_path = work_path / indicator
            if file_path.exists():
                python_files_found.append(indicator)
                if indicator.endswith('.py'):
                    main_files.append(indicator)
        
        if python_files_found:
            result["type"] = "python"
            result["package_manager"] = "pip"
            result["detected_files"] = python_files_found
            result["main_files"] = main_files
            
            # ç¡®å®šé…ç½®æ–‡ä»¶ä¼˜å…ˆçº§
            if "requirements.txt" in python_files_found:
                result["config_file"] = "requirements.txt"
            elif "pyproject.toml" in python_files_found:
                result["config_file"] = "pyproject.toml"
            elif "setup.py" in python_files_found:
                result["config_file"] = "setup.py"
        
        return result


class CommandAnalyzer:
    """å‘½ä»¤åˆ†æå™¨"""
    
    @staticmethod
    def analyze_start_command(project_info: Dict) -> str:
        """
        åˆ†æå¯åŠ¨å‘½ä»¤
        
        Args:
            project_info: ProjectDetector.detect_project_type() çš„è¿”å›å€¼
            
        Returns:
            å¯åŠ¨å‘½ä»¤å­—ç¬¦ä¸²ï¼Œå¦‚ "pnpm dev" æˆ– "python main.py"
        """
        project_type = project_info.get("type", "unknown")
        
        if project_type == "nodejs":
            package_manager = project_info.get("package_manager", "pnpm")
            scripts = project_info.get("scripts", {})
            
            # å¯åŠ¨å‘½ä»¤ä¼˜å…ˆçº§: dev > start > serve > preview
            start_priorities = ["dev", "start", "serve", "preview"]
            
            for script_name in start_priorities:
                if script_name in scripts:
                    return f"{package_manager} {script_name}"
            
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†å¯åŠ¨è„šæœ¬ï¼Œè¿”å›é»˜è®¤
            if scripts:
                # å°è¯•æ‰¾åŒ…å« "dev" æˆ– "start" çš„è„šæœ¬
                for name, command in scripts.items():
                    if any(keyword in name.lower() for keyword in ["dev", "start", "serve"]):
                        return f"{package_manager} {name}"
            
            # æœ€åçš„é»˜è®¤é€‰æ‹©
            return f"{package_manager} start"
        
        elif project_type == "python":
            main_files = project_info.get("main_files", [])
            
            # Python å¯åŠ¨æ–‡ä»¶ä¼˜å…ˆçº§: main.py > app.py > manage.py > run.py
            start_priorities = ["main.py", "app.py", "manage.py", "run.py"]
            
            for main_file in start_priorities:
                if main_file in main_files:
                    return f"python {main_file}"
            
            # å¦‚æœæœ‰å…¶ä»– .py æ–‡ä»¶ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ª
            if main_files:
                return f"python {main_files[0]}"
            
            # é»˜è®¤
            return "python main.py"
        
        else:
            return ""
    
    @staticmethod
    def analyze_build_command(project_info: Dict) -> str:
        """
        åˆ†ææ‰“åŒ…å‘½ä»¤
        
        Args:
            project_info: ProjectDetector.detect_project_type() çš„è¿”å›å€¼
            
        Returns:
            æ‰“åŒ…å‘½ä»¤å­—ç¬¦ä¸²ï¼Œå¦‚ "pnpm build"
        """
        project_type = project_info.get("type", "unknown")
        
        if project_type == "nodejs":
            package_manager = project_info.get("package_manager", "pnpm")
            scripts = project_info.get("scripts", {})
            
            # æ‰“åŒ…å‘½ä»¤ä¼˜å…ˆçº§: build > bundle > dist > compile
            build_priorities = ["build", "bundle", "dist", "compile"]
            
            for script_name in build_priorities:
                if script_name in scripts:
                    return f"{package_manager} {script_name}"
            
            # å°è¯•æ‰¾åŒ…å« "build" çš„è„šæœ¬
            for name, command in scripts.items():
                if any(keyword in name.lower() for keyword in ["build", "bundle", "dist"]):
                    return f"{package_manager} {name}"
            
            # é»˜è®¤
            return f"{package_manager} build"
        
        elif project_type == "python":
            # Python é¡¹ç›®çš„æ‰“åŒ…é€šå¸¸ä½¿ç”¨ setup.py æˆ– pyproject.toml
            config_file = project_info.get("config_file", "")
            
            if config_file == "setup.py":
                return "python setup.py build"
            elif config_file == "pyproject.toml":
                return "python -m build"
            else:
                return "python setup.py build"
        
        else:
            return ""
    
    @staticmethod
    def analyze_install_command(project_info: Dict) -> str:
        """
        åˆ†æä¾èµ–å®‰è£…å‘½ä»¤
        
        Args:
            project_info: ProjectDetector.detect_project_type() çš„è¿”å›å€¼
            
        Returns:
            å®‰è£…å‘½ä»¤å­—ç¬¦ä¸²ï¼Œå¦‚ "pnpm install" æˆ– "pip install -r requirements.txt"
        """
        project_type = project_info.get("type", "unknown")
        
        if project_type == "nodejs":
            package_manager = project_info.get("package_manager", "pnpm")
            return f"{package_manager} install"
        
        elif project_type == "python":
            config_file = project_info.get("config_file", "")
            
            if config_file == "requirements.txt":
                return "pip install -r requirements.txt"
            elif config_file == "pyproject.toml":
                return "pip install -e ."
            elif config_file == "setup.py":
                return "pip install -e ."
            else:
                return "pip install -r requirements.txt"
        
        else:
            return ""


# ============================================
# è¿›ç¨‹ç®¡ç†å™¨ - è·Ÿè¸ªåå°è¿›ç¨‹
# ============================================

class ProcessManager:
    """å…¨å±€è¿›ç¨‹ç®¡ç†å™¨ - è·Ÿè¸ªåå°è¿è¡Œçš„å¼€å‘æœåŠ¡å™¨"""

    def __init__(self):
        self.processes: Dict[int, Dict] = {}
        # {pid: {"command": str, "type": str, "port": str, "started_at": float}}

    def register(self, pid: int, command: str, process_type: str, port: str = ""):
        """æ³¨å†Œè¿›ç¨‹"""
        self.processes[pid] = {
            "command": command,
            "type": process_type,
            "port": port,
            "started_at": time.time()
        }
        print(f"[è¿›ç¨‹ç®¡ç†å™¨] å·²æ³¨å†Œè¿›ç¨‹ PID={pid}, ç«¯å£={port}, ç±»å‹={process_type}")

    def unregister(self, pid: int):
        """æ³¨é”€è¿›ç¨‹"""
        if pid in self.processes:
            del self.processes[pid]
            print(f"[è¿›ç¨‹ç®¡ç†å™¨] å·²æ³¨é”€è¿›ç¨‹ PID={pid}")

    def get_running(self) -> Dict[int, Dict]:
        """è·å–ä»åœ¨è¿è¡Œçš„è¿›ç¨‹"""
        alive = {}
        for pid, info in list(self.processes.items()):
            try:
                os.kill(pid, 0)  # å‘é€ä¿¡å·0æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜åœ¨
                alive[pid] = info
            except (ProcessLookupError, PermissionError):
                # è¿›ç¨‹å·²ä¸å­˜åœ¨,è‡ªåŠ¨æ¸…ç†
                del self.processes[pid]
        return alive

    def kill_all(self) -> List[int]:
        """æ€æ­»æ‰€æœ‰å·²æ³¨å†Œçš„è¿›ç¨‹"""
        killed = []
        for pid in list(self.processes.keys()):
            try:
                # æ€æ­»æ•´ä¸ªè¿›ç¨‹ç»„
                os.killpg(pid, signal.SIGTERM)
                killed.append(pid)
                self.unregister(pid)
            except (ProcessLookupError, PermissionError):
                pass
        return killed


# å…¨å±€å•ä¾‹
process_manager = ProcessManager()


# ============================================
# æ™ºèƒ½æ‰§è¡Œå™¨ - é‡æ„ç‰ˆ
# ============================================

class SmartExecutor:
    """
    æ™ºèƒ½å‘½ä»¤æ‰§è¡Œå™¨ - ç®€åŒ–é‡æ„ç‰ˆ

    æ ¸å¿ƒæ”¹è¿›:
    1. åŒºåˆ† ONESHOT (install/build) å’Œ DAEMON (dev/start)
    2. ä½¿ç”¨ start_new_session åˆ›å»ºç‹¬ç«‹è¿›ç¨‹ç»„
    3. éé˜»å¡è¯»å–è¾“å‡º,é¿å…å¡æ­»
    4. è‡ªåŠ¨æ³¨å†Œåˆ° ProcessManager
    """

    # æˆåŠŸæ¨¡å¼
    SUCCESS_PATTERNS = [
        r"listening on",
        r"local:\s+http://localhost:(\d+)",
        r"ready in",
        r"compiled successfully",
        r"webpack compiled",
        r"server.*?started",
        r"started.*?server",
        r"development server.*?running",
        r"serving at",
        r"started at",
        r"running at",
        r"æœåŠ¡.*?å¯åŠ¨",
        r"å¯åŠ¨.*?æˆåŠŸ",
        r"ç›‘å¬.*?ç«¯å£",
    ]

    # é”™è¯¯æ¨¡å¼
    ERROR_PATTERNS = [
        r"cannot find module",
        r"modulenotfounderror",
        r"no module named",
        r"importerror",
        r"command not found",
        r"fatal error",
        r"critical error",
        r"compilation failed",
        r"port.*?already.*?in.*?use",
        r"address.*?already.*?in.*?use",
    ]

    # éœ€è¦å®‰è£…ä¾èµ–çš„æ¨¡å¼
    INSTALL_NEEDED_PATTERNS = [
        r"cannot find module",
        r"modulenotfounderror",
        r"no module named",
        r"importerror",
        r"missing.*?dependency",
        r"please.*?install",
        r"run.*?install",
    ]

    def execute_oneshot(self, command: str, work_dir: str, timeout: int = 120) -> Dict:
        """
        æ‰§è¡Œå‘½ä»¤å¹¶å®æ—¶ç›‘æ§è¾“å‡º
        
        Args:
            command: è¦æ‰§è¡Œçš„å‘½ä»¤
            work_dir: å·¥ä½œç›®å½•
            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
            project_info: é¡¹ç›®ä¿¡æ¯ï¼ˆç”¨äºè‡ªåŠ¨å®‰è£…ä¾èµ–ï¼‰
            
        Returns:
            {
                "success": bool,
                "output": str,
                "port": str,  # æå–çš„ç«¯å£å·
                "needs_install": bool,  # æ˜¯å¦éœ€è¦å®‰è£…ä¾èµ–
                "error": str,
                "auto_install_triggered": bool,
                "retry_count": int
            }
        """
        if work_dir is None:
            work_dir = WORKING_DIRECTORY
            
        print(f"[æ™ºèƒ½æ‰§è¡Œ] æ‰§è¡Œå‘½ä»¤: {command}")
        print(f"[æ™ºèƒ½æ‰§è¡Œ] å·¥ä½œç›®å½•: {work_dir}")
        
        # é‡ç½®çŠ¶æ€
        self.output_lines = []
        self.error_lines = []
        self.port_detected = ""
        
        result = {
            "success": False,
            "output": "",
            "port": "",
            "needs_install": False,
            "error": "",
            "auto_install_triggered": False,
            "retry_count": 0
        }
        
        # æœ€å¤šé‡è¯• 2 æ¬¡ï¼ˆåŸå§‹æ‰§è¡Œ + 2æ¬¡é‡è¯•ï¼‰
        max_retries = 2
        
        for retry_count in range(max_retries + 1):
            if retry_count > 0:
                print(f"[æ™ºèƒ½æ‰§è¡Œ] ç¬¬ {retry_count} æ¬¡é‡è¯•...")
                result["retry_count"] = retry_count
            
            # æ‰§è¡Œå‘½ä»¤
            exec_result = self._execute_single_command(command, work_dir, timeout, keep_alive)
            
            # æ›´æ–°ç»“æœ
            result["output"] = exec_result["output"]
            result["error"] = exec_result["error"]
            result["port"] = exec_result["port"]
            
            # ä¼ é€’è¿›ç¨‹ä¿¡æ¯
            if "process_id" in exec_result:
                result["process_id"] = exec_result["process_id"]
            if "keep_alive" in exec_result:
                result["keep_alive"] = exec_result["keep_alive"]
            
            # æ£€æŸ¥æ˜¯å¦æˆåŠŸ
            if exec_result["success"]:
                result["success"] = True
                print(f"[æ™ºèƒ½æ‰§è¡Œ] âœ… å‘½ä»¤æ‰§è¡ŒæˆåŠŸ")
                break
            
            # æ£€æŸ¥æ˜¯å¦éœ€è¦å®‰è£…ä¾èµ–
            needs_install = self._check_needs_install(exec_result["output"], exec_result["error"])
            result["needs_install"] = needs_install
            
            if needs_install and project_info and retry_count < max_retries:
                print(f"[æ™ºèƒ½æ‰§è¡Œ] âš ï¸  æ£€æµ‹åˆ°ä¾èµ–ç¼ºå¤±ï¼Œå°è¯•è‡ªåŠ¨å®‰è£…...")
                
                # æ‰§è¡Œå®‰è£…å‘½ä»¤
                install_command = CommandAnalyzer.analyze_install_command(project_info)
                if install_command:
                    print(f"[æ™ºèƒ½æ‰§è¡Œ] ğŸ“¥ æ‰§è¡Œå®‰è£…: {install_command}")
                    install_result = self._execute_single_command(install_command, work_dir, 120, False)  # å®‰è£…è¶…æ—¶2åˆ†é’Ÿï¼Œä¸ä¿æŒè¿è¡Œ
                    
                    if install_result["success"]:
                        print(f"[æ™ºèƒ½æ‰§è¡Œ] âœ… ä¾èµ–å®‰è£…æˆåŠŸ")
                        result["auto_install_triggered"] = True
                        # ç»§ç»­é‡è¯•åŸå‘½ä»¤
                        continue
                    else:
                        print(f"[æ™ºèƒ½æ‰§è¡Œ] âŒ ä¾èµ–å®‰è£…å¤±è´¥: {install_result['error']}")
                        result["error"] = f"ä¾èµ–å®‰è£…å¤±è´¥: {install_result['error']}"
                        break
                else:
                    print(f"[æ™ºèƒ½æ‰§è¡Œ] âŒ æ— æ³•ç¡®å®šå®‰è£…å‘½ä»¤")
                    result["error"] = "æ— æ³•ç¡®å®šä¾èµ–å®‰è£…å‘½ä»¤"
                    break
            else:
                # ä¸éœ€è¦å®‰è£…æˆ–å·²è¾¾åˆ°é‡è¯•ä¸Šé™
                break
        
        return result
    
    def _execute_single_command(self, command: str, work_dir: str, timeout: int, keep_alive: bool = False) -> Dict:
        """
        æ‰§è¡Œå•ä¸ªå‘½ä»¤
        
        Returns:
            {
                "success": bool,
                "output": str,
                "port": str,
                "error": str
            }
        """
        try:
            # é‡ç½®çŠ¶æ€
            self.output_lines = []
            self.error_lines = []
            self.port_detected = ""
            self.is_running = True
            
            # å¯åŠ¨è¿›ç¨‹
            # å¦‚æœéœ€è¦ä¿æŒè¿è¡Œï¼Œåˆ›å»ºç‹¬ç«‹çš„è¿›ç¨‹ç»„
            process_kwargs = {
                "shell": True,
                "cwd": work_dir,
                "stdout": subprocess.PIPE,
                "stderr": subprocess.PIPE,
                "text": True,
                "bufsize": 1,
                "universal_newlines": True
            }
            
            # åœ¨Unixç³»ç»Ÿä¸Šï¼Œå¦‚æœéœ€è¦ä¿æŒè¿è¡Œï¼Œåˆ›å»ºæ–°çš„è¿›ç¨‹ç»„
            if keep_alive and hasattr(os, 'setsid'):
                process_kwargs["preexec_fn"] = os.setsid
            
            self.process = subprocess.Popen(command, **process_kwargs)
            
            # å¯åŠ¨è¾“å‡ºç›‘æ§çº¿ç¨‹
            stdout_thread = threading.Thread(
                target=self._monitor_output,
                args=(self.process.stdout, "stdout"),
                daemon=True
            )
            stderr_thread = threading.Thread(
                target=self._monitor_output,
                args=(self.process.stderr, "stderr"),
                daemon=True
            )
            
            stdout_thread.start()
            stderr_thread.start()
            
            # ç­‰å¾…è¿›ç¨‹å®Œæˆæˆ–è¶…æ—¶
            start_time = time.time()
            success_detected = False
            
            while time.time() - start_time < timeout:
                # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦ç»“æŸ
                if self.process.poll() is not None:
                    break
                
                # æ£€æŸ¥æ˜¯å¦æ£€æµ‹åˆ°æˆåŠŸå¯åŠ¨
                if self._check_success_patterns():
                    success_detected = True
                    print(f"[æ™ºèƒ½æ‰§è¡Œ] âœ… æ£€æµ‹åˆ°å¯åŠ¨æˆåŠŸæ¨¡å¼")
                    break
                
                time.sleep(0.5)
            
            # æ ¹æ®keep_aliveå‚æ•°å†³å®šæ˜¯å¦ç»ˆæ­¢è¿›ç¨‹
            should_keep_running = False
            if self.process.poll() is None:
                if success_detected and keep_alive:
                    # æˆåŠŸå¯åŠ¨ä¸”éœ€è¦ä¿æŒè¿è¡Œï¼Œè®©è¿›ç¨‹ç»§ç»­åœ¨åå°è¿è¡Œ
                    print(f"[æ™ºèƒ½æ‰§è¡Œ] ğŸš€ è¿›ç¨‹å°†ç»§ç»­åœ¨åå°è¿è¡Œ (PID: {self.process.pid})")
                    time.sleep(2)  # ç­‰å¾…ä¸€ä¸‹ç¡®ä¿ç¨³å®š
                    should_keep_running = True
                    # ä¸ç»ˆæ­¢è¿›ç¨‹ï¼Œè®©å®ƒç»§ç»­è¿è¡Œ
                elif success_detected:
                    # æˆåŠŸå¯åŠ¨ä½†ä¸éœ€è¦ä¿æŒè¿è¡Œï¼ˆå¦‚æ„å»ºä»»åŠ¡ï¼‰
                    time.sleep(2)
                    self.process.terminate()
                    try:
                        self.process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        self.process.kill()
                else:
                    # è¶…æ—¶ï¼Œå¼ºåˆ¶ç»ˆæ­¢
                    print(f"[æ™ºèƒ½æ‰§è¡Œ] â° å‘½ä»¤æ‰§è¡Œè¶…æ—¶ ({timeout}s)")
                    self.process.terminate()
                    try:
                        self.process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        self.process.kill()
            
            # åªæœ‰åœ¨ä¸éœ€è¦ä¿æŒè¿è¡Œæ—¶æ‰åœæ­¢ç›‘æ§
            if not should_keep_running:
                self.is_running = False
                # ç­‰å¾…çº¿ç¨‹ç»“æŸ
                stdout_thread.join(timeout=2)
                stderr_thread.join(timeout=2)
            else:
                # ä¿æŒè¿è¡Œæ—¶ï¼Œç»™ç›‘æ§çº¿ç¨‹ä¸€ç‚¹æ—¶é—´ç¨³å®šï¼Œå¹¶ç»§ç»­ç›‘æ§ä¸€æ®µæ—¶é—´
                print(f"[æ™ºèƒ½æ‰§è¡Œ] ğŸ”„ ç»§ç»­ç›‘æ§è¿›ç¨‹ç¨³å®šæ€§...")
                
                # ç»§ç»­ç›‘æ§10ç§’ï¼Œç¡®ä¿è¿›ç¨‹ç¨³å®š
                stable_check_time = 10
                for i in range(stable_check_time):
                    time.sleep(1)
                    if self.process.poll() is not None:
                        print(f"[æ™ºèƒ½æ‰§è¡Œ] âš ï¸  è¿›ç¨‹åœ¨å¯åŠ¨å {i+1} ç§’æ—¶æ„å¤–åœæ­¢")
                        print(f"[æ™ºèƒ½æ‰§è¡Œ] ğŸ“‹ è¿›ç¨‹é€€å‡ºç : {self.process.returncode}")
                        # æ”¶é›†å‰©ä½™è¾“å‡º
                        time.sleep(0.5)
                        break
                    elif i == stable_check_time - 1:
                        print(f"[æ™ºèƒ½æ‰§è¡Œ] âœ… è¿›ç¨‹è¿è¡Œç¨³å®š ({stable_check_time}ç§’æ£€æŸ¥é€šè¿‡)")
                
                # å¦‚æœè¿›ç¨‹åœ¨ç¨³å®šæ€§æ£€æŸ¥æœŸé—´åœæ­¢äº†ï¼Œæ›´æ–°ç»“æœ
                if self.process.poll() is not None:
                    should_keep_running = False
                    self.is_running = False
            
            # æ•´ç†è¾“å‡º
            output = "\n".join(self.output_lines)
            error = "\n".join(self.error_lines)
            
            # åˆ¤æ–­æˆåŠŸæ¡ä»¶
            return_code = self.process.returncode if self.process else -1
            process_still_running = self.process and self.process.poll() is None
            
            # æˆåŠŸæ¡ä»¶æ ¹æ®æ˜¯å¦éœ€è¦ä¿æŒè¿è¡Œæ¥åˆ¤æ–­
            if keep_alive:
                # éœ€è¦ä¿æŒè¿è¡Œï¼šå¿…é¡»æ£€æµ‹åˆ°å¯åŠ¨æˆåŠŸä¸”è¿›ç¨‹ä»åœ¨è¿è¡Œ
                success = success_detected and process_still_running
                if success_detected and not process_still_running:
                    # å¯åŠ¨æˆåŠŸä½†è¿›ç¨‹å·²åœæ­¢ï¼Œè®°å½•é”™è¯¯
                    error += f"\nâš ï¸  è¿›ç¨‹å¯åŠ¨åæ„å¤–åœæ­¢ (é€€å‡ºç : {return_code})"
            else:
                # ä¸éœ€è¦ä¿æŒè¿è¡Œï¼šæ£€æµ‹åˆ°æˆåŠŸæ¨¡å¼æˆ–è¿”å›ç ä¸º0
                success = (
                    success_detected or 
                    (return_code == 0 and not self._check_error_patterns(output, error))
                )
            
            result = {
                "success": success,
                "output": output,
                "port": self.port_detected,
                "error": error if not success else ""
            }
            
            # å¦‚æœè¿›ç¨‹ä»åœ¨è¿è¡Œä¸”éœ€è¦ä¿æŒè¿è¡Œï¼Œæ·»åŠ è¿›ç¨‹ID
            if process_still_running and keep_alive:
                result["process_id"] = self.process.pid
                result["keep_alive"] = True
            
            return result
            
        except Exception as e:
            print(f"[æ™ºèƒ½æ‰§è¡Œ] âŒ æ‰§è¡Œå¼‚å¸¸: {e}")
            return {
                "success": False,
                "output": "",
                "port": "",
                "error": f"æ‰§è¡Œå¼‚å¸¸: {str(e)}"
            }
    
    def _monitor_output(self, pipe, pipe_name: str):
        """ç›‘æ§è¿›ç¨‹è¾“å‡º"""
        try:
            for line in iter(pipe.readline, ''):
                if not self.is_running:
                    break
                
                line = line.strip()
                if line:
                    if pipe_name == "stdout":
                        self.output_lines.append(line)
                        print(f"[è¾“å‡º] {line}")
                    else:
                        self.error_lines.append(line)
                        print(f"[é”™è¯¯] {line}")
                    
                    # å®æ—¶æ£€æµ‹ç«¯å£
                    port = self._extract_port(line)
                    if port:
                        self.port_detected = port
                        print(f"[æ™ºèƒ½æ‰§è¡Œ] ğŸŒ æ£€æµ‹åˆ°ç«¯å£: {port}")
        except Exception as e:
            print(f"[æ™ºèƒ½æ‰§è¡Œ] è¾“å‡ºç›‘æ§å¼‚å¸¸: {e}")
    
    def _extract_port(self, line: str) -> str:
        """ä»è¾“å‡ºè¡Œä¸­æå–ç«¯å£å·"""
        # å¸¸è§çš„ç«¯å£æ¨¡å¼
        port_patterns = [
            r"listening on.*?:(\d+)",
            r"started.*?:(\d+)",
            r"server.*?:(\d+)",
            r"http://localhost:(\d+)",
            r"https://localhost:(\d+)",
            r"Local:\s+http://localhost:(\d+)",
            r"Network:\s+http://.*?:(\d+)",
            r"port\s+(\d+)",
            r"ç«¯å£\s*[:ï¼š]\s*(\d+)",
            r"ç›‘å¬.*?(\d+)",
        ]
        
        line_lower = line.lower()
        for pattern in port_patterns:
            match = re.search(pattern, line_lower)
            if match:
                return match.group(1)
        
        return ""
    
    def _check_success_patterns(self) -> bool:
        """æ£€æŸ¥æˆåŠŸå¯åŠ¨çš„æ¨¡å¼"""
        all_output = "\n".join(self.output_lines + self.error_lines).lower()
        
        success_patterns = [
            r"listening on",
            r"server.*?started",
            r"started.*?server",
            r"ready in",
            r"compiled successfully",
            r"webpack compiled",
            r"development server.*?running",
            r"local:\s+http",
            r"network:\s+http",
            r"serving at",
            r"started at",
            r"running at",
            r"æœåŠ¡.*?å¯åŠ¨",
            r"å¯åŠ¨.*?æˆåŠŸ",
            r"ç›‘å¬.*?ç«¯å£",
        ]
        
        for pattern in success_patterns:
            if re.search(pattern, all_output):
                return True
        
        return False
    
    def _check_needs_install(self, output: str, error: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦éœ€è¦å®‰è£…ä¾èµ–"""
        all_text = (output + "\n" + error).lower()
        
        install_patterns = [
            r"command not found",
            r"cannot find module",
            r"modulenotfounderror",
            r"no module named",
            r"importerror",
            r"missing.*?dependency",
            r"dependencies.*?not.*?found",
            r"please.*?install",
            r"run.*?install",
            r"npm install",
            r"pnpm install",
            r"yarn install",
            r"pip install",
            r"æœªæ‰¾åˆ°.*?æ¨¡å—",
            r"ç¼ºå°‘.*?ä¾èµ–",
            r"è¯·.*?å®‰è£…",
        ]
        
        for pattern in install_patterns:
            if re.search(pattern, all_text):
                return True
        
        return False
    
    def _check_error_patterns(self, output: str, error: str) -> bool:
        """æ£€æŸ¥ä¸¥é‡é”™è¯¯æ¨¡å¼"""
        all_text = (output + "\n" + error).lower()
        
        error_patterns = [
            r"fatal error",
            r"critical error",
            r"compilation failed",
            r"build failed",
            r"syntax error",
            r"permission denied",
            r"access denied",
            r"port.*?already.*?in.*?use",
            r"address.*?already.*?in.*?use",
            r"ç«¯å£.*?è¢«å ç”¨",
            r"åœ°å€.*?è¢«å ç”¨",
        ]
        
        for pattern in error_patterns:
            if re.search(pattern, all_text):
                return True
        
        return False


# ============================================
# LangChain Tool å°è£…
# ============================================

def start_project_tool_func(input_str: str) -> str:
    """
    å¯åŠ¨é¡¹ç›®å·¥å…·å‡½æ•°
    
    Args:
        input_str: JSONæ ¼å¼è¾“å…¥ï¼ˆå¯é€‰ï¼‰ï¼Œä¾‹å¦‚ {"work_dir": "/path/to/project"}
        
    Returns:
        å¯åŠ¨ç»“æœçš„æ–‡æœ¬æè¿°
    """
    try:
        # è§£æè¾“å…¥ï¼ˆå¯é€‰ï¼‰
        # ä¼˜å…ˆä½¿ç”¨å½“å‰å·¥ä½œç›®å½•ï¼Œè€Œä¸æ˜¯é…ç½®çš„å·¥ä½œç›®å½•
        work_dir = os.getcwd()
        if input_str.strip():
            try:
                data = json.loads(input_str)
                work_dir = data.get("work_dir", os.getcwd())
            except json.JSONDecodeError:
                # å¦‚æœä¸æ˜¯JSONï¼Œå¿½ç•¥è¾“å…¥ï¼Œä½¿ç”¨å½“å‰ç›®å½•
                pass
        
        print(f"\nğŸš€ [é¡¹ç›®å¯åŠ¨] å¼€å§‹å¯åŠ¨é¡¹ç›®...")
        print(f"[é¡¹ç›®å¯åŠ¨] å·¥ä½œç›®å½•: {work_dir}")
        
        # 1. æ£€æµ‹é¡¹ç›®ç±»å‹
        print(f"ğŸ” æ£€æµ‹é¡¹ç›®ç±»å‹...")
        project_info = ProjectDetector.detect_project_type(work_dir)
        
        if project_info["type"] == "unknown":
            return """âŒ é¡¹ç›®å¯åŠ¨å¤±è´¥

ğŸ” æœªèƒ½è¯†åˆ«é¡¹ç›®ç±»å‹
   
ğŸ’¡ æ”¯æŒçš„é¡¹ç›®ç±»å‹:
   â€¢ Node.js é¡¹ç›® (éœ€è¦ package.json)
   â€¢ Python é¡¹ç›® (éœ€è¦ main.py, app.py æˆ– requirements.txt)
   
è¯·ç¡®ä¿åœ¨æ­£ç¡®çš„é¡¹ç›®ç›®å½•ä¸­æ‰§è¡Œæ­¤å‘½ä»¤ã€‚"""
        
        # 2. æ˜¾ç¤ºæ£€æµ‹ç»“æœ
        result_text = f"""âœ… æ£€æµ‹åˆ° {project_info['type'].upper()} é¡¹ç›®
ğŸ“¦ åŒ…ç®¡ç†å™¨: {project_info['package_manager']}
ğŸ“„ é…ç½®æ–‡ä»¶: {project_info['config_file']}
ğŸ“ æ£€æµ‹åˆ°çš„æ–‡ä»¶: {', '.join(project_info['detected_files'])}"""
        
        if project_info['type'] == 'nodejs' and project_info['scripts']:
            result_text += f"\nğŸ› ï¸  å¯ç”¨è„šæœ¬: {', '.join(project_info['scripts'].keys())}"
        elif project_info['type'] == 'python' and project_info['main_files']:
            result_text += f"\nğŸ ä¸»æ–‡ä»¶: {', '.join(project_info['main_files'])}"
        
        print(result_text)
        
        # 3. åˆ†æå¯åŠ¨å‘½ä»¤
        command = CommandAnalyzer.analyze_start_command(project_info)
        if not command:
            return f"""âŒ é¡¹ç›®å¯åŠ¨å¤±è´¥

{result_text}

âŒ æ— æ³•ç¡®å®šå¯åŠ¨å‘½ä»¤
   
ğŸ’¡ è¯·æ£€æŸ¥é¡¹ç›®é…ç½®:
   â€¢ Node.js: ç¡®ä¿ package.json ä¸­æœ‰ dev/start/serve è„šæœ¬
   â€¢ Python: ç¡®ä¿æœ‰ main.py, app.py æˆ–å…¶ä»–å¯åŠ¨æ–‡ä»¶"""
        
        print(f"ğŸš€ å¯åŠ¨å‘½ä»¤: {command}")
        
        # 4. æ™ºèƒ½æ‰§è¡Œ
        print(f"âš™ï¸  æ‰§è¡Œä¸­...")
        executor = SmartExecutor()
        exec_result = executor.execute_with_monitoring(
            command=command,
            work_dir=work_dir,
            timeout=30,
            project_info=project_info,
            keep_alive=True  # å¯åŠ¨é¡¹ç›®æ—¶ä¿æŒè¿›ç¨‹è¿è¡Œ
        )
        
        # 5. æ ¼å¼åŒ–ç»“æœ
        final_result = f"""{result_text}
ğŸš€ å¯åŠ¨å‘½ä»¤: {command}

"""
        
        if exec_result["auto_install_triggered"]:
            install_cmd = CommandAnalyzer.analyze_install_command(project_info)
            final_result += f"""âš ï¸  æ£€æµ‹åˆ°ä¾èµ–æœªå®‰è£…
ğŸ“¥ è‡ªåŠ¨æ‰§è¡Œ: {install_cmd}
   âœ“ ä¾èµ–å®‰è£…å®Œæˆ

"""
        
        if exec_result["retry_count"] > 0:
            final_result += f"ğŸ”„ é‡è¯•æ¬¡æ•°: {exec_result['retry_count']}\n\n"
        
        if exec_result["success"]:
            final_result += "ğŸ‰ é¡¹ç›®å¯åŠ¨æˆåŠŸï¼\n"
            
            if exec_result["port"]:
                final_result += f"""   ğŸŒ è®¿é—®åœ°å€: http://localhost:{exec_result['port']}
   ğŸ“Š ç«¯å£: {exec_result['port']}"""
            else:
                final_result += "   âœ… æœåŠ¡å·²å¯åŠ¨"
            
            # æ·»åŠ è¿›ç¨‹ä¿¡æ¯
            if exec_result.get("keep_alive") and exec_result.get("process_id"):
                final_result += f"""
   ğŸš€ è¿›ç¨‹ID: {exec_result['process_id']} (åå°è¿è¡Œä¸­)
   
ğŸ’¡ æç¤º: å¼€å‘æœåŠ¡å™¨æ­£åœ¨åå°è¿è¡Œï¼Œå¯ä»¥é€šè¿‡æµè§ˆå™¨è®¿é—®ä¸Šè¿°åœ°å€
ğŸ’¡ åœæ­¢æœåŠ¡: kill {exec_result['process_id']} æˆ–ä½¿ç”¨ "åœæ­¢é¡¹ç›®" å‘½ä»¤"""
            
            if exec_result["output"]:
                # æ˜¾ç¤ºæœ€åå‡ è¡Œè¾“å‡º
                output_lines = exec_result["output"].split('\n')
                last_lines = output_lines[-3:] if len(output_lines) > 3 else output_lines
                if last_lines:
                    final_result += f"\n\nğŸ“‹ å¯åŠ¨æ—¥å¿—:\n   " + "\n   ".join(last_lines)
        else:
            final_result += f"""âŒ é¡¹ç›®å¯åŠ¨å¤±è´¥

é”™è¯¯ä¿¡æ¯:
{exec_result['error']}"""
            
            if exec_result["needs_install"] and not exec_result["auto_install_triggered"]:
                install_cmd = CommandAnalyzer.analyze_install_command(project_info)
                final_result += f"""

ğŸ’¡ å¯èƒ½éœ€è¦å®‰è£…ä¾èµ–:
   {install_cmd}"""
        
        return final_result
        
    except Exception as e:
        return f"""âŒ é¡¹ç›®å¯åŠ¨å¤±è´¥

æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {str(e)}

ğŸ’¡ è¯·æ£€æŸ¥:
   â€¢ æ˜¯å¦åœ¨æ­£ç¡®çš„é¡¹ç›®ç›®å½•ä¸­
   â€¢ é¡¹ç›®é…ç½®æ˜¯å¦æ­£ç¡®
   â€¢ æ˜¯å¦æœ‰å¿…è¦çš„æƒé™"""


def diagnose_project_tool_func(input_str: str) -> str:
    """
    è¯Šæ–­é¡¹ç›®çŠ¶æ€å·¥å…·å‡½æ•°
    
    Args:
        input_str: JSONæ ¼å¼è¾“å…¥ï¼Œä¾‹å¦‚ {"pid": "12345", "port": "3001"}
        
    Returns:
        è¯Šæ–­ç»“æœçš„æ–‡æœ¬æè¿°
    """
    try:
        # è§£æè¾“å…¥
        pid = None
        port = None
        
        if input_str.strip():
            try:
                data = json.loads(input_str)
                pid = data.get("pid")
                port = data.get("port")
            except json.JSONDecodeError:
                pass
        
        print(f"\nğŸ” [é¡¹ç›®è¯Šæ–­] å¼€å§‹è¯Šæ–­é¡¹ç›®çŠ¶æ€...")
        
        result_text = "ğŸ” é¡¹ç›®çŠ¶æ€è¯Šæ–­æŠ¥å‘Š\n\n"
        
        # 1. æ£€æŸ¥è¿›ç¨‹çŠ¶æ€
        if pid:
            result_text += f"1ï¸âƒ£ è¿›ç¨‹çŠ¶æ€æ£€æŸ¥ (PID: {pid}):\n"
            try:
                import signal
                os.kill(int(pid), 0)  # å‘é€ä¿¡å·0æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜åœ¨
                result_text += f"   âœ… è¿›ç¨‹ {pid} æ­£åœ¨è¿è¡Œ\n"
                
                # è·å–è¿›ç¨‹è¯¦ç»†ä¿¡æ¯
                try:
                    import subprocess
                    ps_result = subprocess.run(
                        ["ps", "-p", str(pid), "-o", "pid,ppid,cmd"],
                        capture_output=True,
                        text=True
                    )
                    if ps_result.returncode == 0:
                        result_text += f"   ğŸ“‹ è¿›ç¨‹ä¿¡æ¯:\n"
                        for line in ps_result.stdout.strip().split('\n')[1:]:  # è·³è¿‡æ ‡é¢˜è¡Œ
                            result_text += f"      {line}\n"
                except:
                    pass
                    
            except ProcessLookupError:
                result_text += f"   âŒ è¿›ç¨‹ {pid} ä¸å­˜åœ¨æˆ–å·²åœæ­¢\n"
            except (ValueError, PermissionError):
                result_text += f"   âš ï¸  æ— æ³•æ£€æŸ¥è¿›ç¨‹ {pid} çŠ¶æ€\n"
        else:
            result_text += "1ï¸âƒ£ è¿›ç¨‹çŠ¶æ€æ£€æŸ¥: æœªæä¾›PID\n"
        
        result_text += "\n"
        
        # 2. æ£€æŸ¥ç«¯å£ç›‘å¬çŠ¶æ€
        if port:
            result_text += f"2ï¸âƒ£ ç«¯å£ç›‘å¬æ£€æŸ¥ (ç«¯å£: {port}):\n"
            try:
                import subprocess
                lsof_result = subprocess.run(
                    ["lsof", "-i", f":{port}"],
                    capture_output=True,
                    text=True
                )
                
                if lsof_result.returncode == 0 and lsof_result.stdout.strip():
                    result_text += f"   âœ… ç«¯å£ {port} æ­£åœ¨è¢«ç›‘å¬\n"
                    result_text += f"   ğŸ“‹ ç›‘å¬è¯¦æƒ…:\n"
                    for line in lsof_result.stdout.strip().split('\n')[1:]:  # è·³è¿‡æ ‡é¢˜è¡Œ
                        result_text += f"      {line}\n"
                else:
                    result_text += f"   âŒ ç«¯å£ {port} æ²¡æœ‰è¢«ç›‘å¬\n"
                    
            except FileNotFoundError:
                result_text += f"   âš ï¸  ç³»ç»Ÿä¸æ”¯æŒ lsof å‘½ä»¤\n"
            except Exception as e:
                result_text += f"   âŒ æ£€æŸ¥ç«¯å£æ—¶å‡ºé”™: {str(e)}\n"
        else:
            result_text += "2ï¸âƒ£ ç«¯å£ç›‘å¬æ£€æŸ¥: æœªæä¾›ç«¯å£å·\n"
        
        result_text += "\n"
        
        # 3. å°è¯•è¿æ¥æµ‹è¯•
        if port:
            result_text += f"3ï¸âƒ£ è¿æ¥æµ‹è¯• (http://localhost:{port}):\n"
            try:
                import urllib.request
                import socket
                
                # è®¾ç½®è¶…æ—¶
                socket.setdefaulttimeout(5)
                
                try:
                    response = urllib.request.urlopen(f"http://localhost:{port}")
                    status_code = response.getcode()
                    result_text += f"   âœ… è¿æ¥æˆåŠŸï¼ŒçŠ¶æ€ç : {status_code}\n"
                    
                    # è¯»å–éƒ¨åˆ†å“åº”å†…å®¹
                    content = response.read(500).decode('utf-8', errors='ignore')
                    if content:
                        result_text += f"   ğŸ“„ å“åº”å†…å®¹é¢„è§ˆ: {content[:100]}...\n"
                        
                except urllib.error.HTTPError as e:
                    result_text += f"   âš ï¸  HTTPé”™è¯¯: {e.code} {e.reason}\n"
                except urllib.error.URLError as e:
                    result_text += f"   âŒ è¿æ¥å¤±è´¥: {str(e.reason)}\n"
                except socket.timeout:
                    result_text += f"   â° è¿æ¥è¶…æ—¶ (5ç§’)\n"
                except Exception as e:
                    result_text += f"   âŒ è¿æ¥æµ‹è¯•å¤±è´¥: {str(e)}\n"
                    
            except Exception as e:
                result_text += f"   âŒ æ— æ³•è¿›è¡Œè¿æ¥æµ‹è¯•: {str(e)}\n"
        else:
            result_text += "3ï¸âƒ£ è¿æ¥æµ‹è¯•: æœªæä¾›ç«¯å£å·\n"
        
        result_text += "\n"
        
        # 4. å¸¸è§é—®é¢˜è¯Šæ–­å’Œå»ºè®®
        result_text += "4ï¸âƒ£ è¯Šæ–­å»ºè®®:\n"
        
        if pid and port:
            # æ£€æŸ¥è¿›ç¨‹å’Œç«¯å£çš„åŒ¹é…æ€§
            try:
                import subprocess
                lsof_result = subprocess.run(
                    ["lsof", "-p", str(pid), "-i", f":{port}"],
                    capture_output=True,
                    text=True
                )
                
                if lsof_result.returncode == 0 and lsof_result.stdout.strip():
                    result_text += "   âœ… è¿›ç¨‹å’Œç«¯å£åŒ¹é…æ­£å¸¸\n"
                else:
                    result_text += "   âš ï¸  è¿›ç¨‹å’Œç«¯å£å¯èƒ½ä¸åŒ¹é…\n"
                    result_text += "   ğŸ’¡ å»ºè®®: æ£€æŸ¥è¿›ç¨‹æ˜¯å¦çœŸçš„åœ¨ç›‘å¬æŒ‡å®šç«¯å£\n"
            except:
                pass
        
        # é€šç”¨å»ºè®®
        result_text += """
ğŸ’¡ å¸¸è§è§£å†³æ–¹æ¡ˆ:
   â€¢ æµè§ˆå™¨ç¼“å­˜: å°è¯•ç¡¬åˆ·æ–° (Ctrl+Shift+R æˆ– Cmd+Shift+R)
   â€¢ æµè§ˆå™¨éšç§æ¨¡å¼: å°è¯•åœ¨éšç§/æ— ç—•æ¨¡å¼ä¸‹è®¿é—®
   â€¢ é˜²ç«å¢™: æ£€æŸ¥ç³»ç»Ÿé˜²ç«å¢™æ˜¯å¦é˜»æ­¢äº†ç«¯å£è®¿é—®
   â€¢ åº”ç”¨é”™è¯¯: æ£€æŸ¥åº”ç”¨æ—¥å¿—æ˜¯å¦æœ‰é”™è¯¯ä¿¡æ¯
   â€¢ ç«¯å£å†²çª: å°è¯•é‡å¯é¡¹ç›®ä½¿ç”¨ä¸åŒç«¯å£
   
ğŸ”§ å¿«é€Ÿæ“ä½œ:
   â€¢ é‡å¯é¡¹ç›®: å…ˆä½¿ç”¨ "åœæ­¢é¡¹ç›®" å†ä½¿ç”¨ "å¯åŠ¨é¡¹ç›®"
   â€¢ æŸ¥çœ‹æ—¥å¿—: æ£€æŸ¥é¡¹ç›®çš„é”™è¯¯æ—¥å¿—
   â€¢ æ‰‹åŠ¨æµ‹è¯•: curl http://localhost:{port or 'PORT'}"""
        
        return result_text
        
    except Exception as e:
        return f"""âŒ é¡¹ç›®è¯Šæ–­å¤±è´¥

æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {str(e)}

ğŸ’¡ è¯·å°è¯•æ‰‹åŠ¨æ£€æŸ¥:
   â€¢ ps aux | grep {pid or 'PID'}
   â€¢ lsof -i :{port or 'PORT'}
   â€¢ curl http://localhost:{port or 'PORT'}"""


def stop_project_tool_func(input_str: str) -> str:
    """
    åœæ­¢é¡¹ç›®å·¥å…·å‡½æ•°
    
    Args:
        input_str: JSONæ ¼å¼è¾“å…¥ï¼ˆå¯é€‰ï¼‰ï¼Œä¾‹å¦‚ {"port": "3000"} æˆ– {"pid": "12345"}
        
    Returns:
        åœæ­¢ç»“æœçš„æ–‡æœ¬æè¿°
    """
    try:
        # è§£æè¾“å…¥ï¼ˆå¯é€‰ï¼‰
        port = None
        pid = None
        
        if input_str.strip():
            try:
                data = json.loads(input_str)
                port = data.get("port")
                pid = data.get("pid")
            except json.JSONDecodeError:
                pass
        
        print(f"\nğŸ›‘ [é¡¹ç›®åœæ­¢] å¼€å§‹åœæ­¢é¡¹ç›®...")
        
        stopped_processes = []
        
        # å¦‚æœæŒ‡å®šäº†PIDï¼Œç›´æ¥åœæ­¢
        if pid:
            try:
                import signal
                os.kill(int(pid), signal.SIGTERM)
                stopped_processes.append(f"PID {pid}")
                print(f"[é¡¹ç›®åœæ­¢] âœ… å·²åœæ­¢è¿›ç¨‹ {pid}")
            except (ProcessLookupError, ValueError):
                print(f"[é¡¹ç›®åœæ­¢] âš ï¸  è¿›ç¨‹ {pid} ä¸å­˜åœ¨æˆ–å·²åœæ­¢")
            except PermissionError:
                print(f"[é¡¹ç›®åœæ­¢] âŒ æ²¡æœ‰æƒé™åœæ­¢è¿›ç¨‹ {pid}")
                return f"âŒ æ²¡æœ‰æƒé™åœæ­¢è¿›ç¨‹ {pid}"
        
        # å¦‚æœæŒ‡å®šäº†ç«¯å£ï¼ŒæŸ¥æ‰¾å¹¶åœæ­¢å ç”¨è¯¥ç«¯å£çš„è¿›ç¨‹
        elif port:
            try:
                import subprocess
                # ä½¿ç”¨ lsof æŸ¥æ‰¾å ç”¨ç«¯å£çš„è¿›ç¨‹
                result = subprocess.run(
                    ["lsof", "-ti", f":{port}"],
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0 and result.stdout.strip():
                    pids = result.stdout.strip().split('\n')
                    for pid_str in pids:
                        try:
                            import signal
                            pid_int = int(pid_str)
                            os.kill(pid_int, signal.SIGTERM)
                            stopped_processes.append(f"PID {pid_int}")
                            print(f"[é¡¹ç›®åœæ­¢] âœ… å·²åœæ­¢å ç”¨ç«¯å£ {port} çš„è¿›ç¨‹ {pid_int}")
                        except (ProcessLookupError, ValueError):
                            print(f"[é¡¹ç›®åœæ­¢] âš ï¸  è¿›ç¨‹ {pid_str} ä¸å­˜åœ¨æˆ–å·²åœæ­¢")
                else:
                    print(f"[é¡¹ç›®åœæ­¢] âš ï¸  ç«¯å£ {port} æ²¡æœ‰è¢«å ç”¨")
                    return f"âš ï¸  ç«¯å£ {port} æ²¡æœ‰è¢«å ç”¨"
                    
            except FileNotFoundError:
                return "âŒ ç³»ç»Ÿä¸æ”¯æŒ lsof å‘½ä»¤ï¼Œè¯·æ‰‹åŠ¨æŒ‡å®šè¿›ç¨‹ID"
        
        # å¦‚æœæ²¡æœ‰æŒ‡å®šç«¯å£æˆ–PIDï¼Œå°è¯•åœæ­¢å¸¸è§çš„å¼€å‘æœåŠ¡å™¨ç«¯å£
        else:
            common_ports = ["3000", "8000", "5173", "4200", "8080"]
            for common_port in common_ports:
                try:
                    result = subprocess.run(
                        ["lsof", "-ti", f":{common_port}"],
                        capture_output=True,
                        text=True
                    )
                    
                    if result.returncode == 0 and result.stdout.strip():
                        pids = result.stdout.strip().split('\n')
                        for pid_str in pids:
                            try:
                                import signal
                                pid_int = int(pid_str)
                                os.kill(pid_int, signal.SIGTERM)
                                stopped_processes.append(f"ç«¯å£ {common_port} (PID {pid_int})")
                                print(f"[é¡¹ç›®åœæ­¢] âœ… å·²åœæ­¢ç«¯å£ {common_port} çš„è¿›ç¨‹ {pid_int}")
                            except (ProcessLookupError, ValueError):
                                continue
                except:
                    continue
        
        # ç”Ÿæˆç»“æœ
        if stopped_processes:
            result_text = f"""ğŸ›‘ é¡¹ç›®åœæ­¢å®Œæˆï¼

âœ… å·²åœæ­¢çš„è¿›ç¨‹:
"""
            for process in stopped_processes:
                result_text += f"   â€¢ {process}\n"
            
            result_text += """
ğŸ’¡ æç¤º: å¦‚æœéœ€è¦é‡æ–°å¯åŠ¨é¡¹ç›®ï¼Œè¯·ä½¿ç”¨ "å¯åŠ¨é¡¹ç›®" å‘½ä»¤"""
            
            return result_text
        else:
            return """âš ï¸  æ²¡æœ‰æ‰¾åˆ°è¿è¡Œä¸­çš„é¡¹ç›®è¿›ç¨‹

ğŸ’¡ æç¤º: 
   â€¢ ä½¿ç”¨ "åœæ­¢é¡¹ç›® ç«¯å£:3000" æŒ‡å®šç«¯å£
   â€¢ ä½¿ç”¨ "åœæ­¢é¡¹ç›® è¿›ç¨‹:12345" æŒ‡å®šè¿›ç¨‹ID
   â€¢ æˆ–è€…æ‰‹åŠ¨æ‰§è¡Œ: kill <è¿›ç¨‹ID>"""
        
    except Exception as e:
        return f"""âŒ åœæ­¢é¡¹ç›®å¤±è´¥

æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {str(e)}

ğŸ’¡ è¯·å°è¯•æ‰‹åŠ¨åœæ­¢: kill <è¿›ç¨‹ID>"""


def build_project_tool_func(input_str: str) -> str:
    """
    æ‰“åŒ…é¡¹ç›®å·¥å…·å‡½æ•°
    
    Args:
        input_str: JSONæ ¼å¼è¾“å…¥ï¼ˆå¯é€‰ï¼‰ï¼Œä¾‹å¦‚ {"work_dir": "/path/to/project"}
        
    Returns:
        æ‰“åŒ…ç»“æœçš„æ–‡æœ¬æè¿°
    """
    try:
        # è§£æè¾“å…¥ï¼ˆå¯é€‰ï¼‰
        # ä¼˜å…ˆä½¿ç”¨å½“å‰å·¥ä½œç›®å½•ï¼Œè€Œä¸æ˜¯é…ç½®çš„å·¥ä½œç›®å½•
        work_dir = os.getcwd()
        if input_str.strip():
            try:
                data = json.loads(input_str)
                work_dir = data.get("work_dir", os.getcwd())
            except json.JSONDecodeError:
                pass
        
        print(f"\nğŸ“¦ [é¡¹ç›®æ‰“åŒ…] å¼€å§‹æ‰“åŒ…é¡¹ç›®...")
        print(f"[é¡¹ç›®æ‰“åŒ…] å·¥ä½œç›®å½•: {work_dir}")
        
        # 1. æ£€æµ‹é¡¹ç›®ç±»å‹
        print(f"ğŸ” æ£€æµ‹é¡¹ç›®ç±»å‹...")
        project_info = ProjectDetector.detect_project_type(work_dir)
        
        if project_info["type"] == "unknown":
            return """âŒ é¡¹ç›®æ‰“åŒ…å¤±è´¥

ğŸ” æœªèƒ½è¯†åˆ«é¡¹ç›®ç±»å‹
   
ğŸ’¡ æ”¯æŒçš„é¡¹ç›®ç±»å‹:
   â€¢ Node.js é¡¹ç›® (éœ€è¦ package.json)
   â€¢ Python é¡¹ç›® (éœ€è¦ setup.py æˆ– pyproject.toml)"""
        
        # 2. æ˜¾ç¤ºæ£€æµ‹ç»“æœ
        result_text = f"""âœ… æ£€æµ‹åˆ° {project_info['type'].upper()} é¡¹ç›®
ğŸ“¦ åŒ…ç®¡ç†å™¨: {project_info['package_manager']}
ğŸ“„ é…ç½®æ–‡ä»¶: {project_info['config_file']}"""
        
        print(result_text)
        
        # 3. åˆ†ææ‰“åŒ…å‘½ä»¤
        command = CommandAnalyzer.analyze_build_command(project_info)
        if not command:
            return f"""âŒ é¡¹ç›®æ‰“åŒ…å¤±è´¥

{result_text}

âŒ æ— æ³•ç¡®å®šæ‰“åŒ…å‘½ä»¤
   
ğŸ’¡ è¯·æ£€æŸ¥é¡¹ç›®é…ç½®:
   â€¢ Node.js: ç¡®ä¿ package.json ä¸­æœ‰ build è„šæœ¬
   â€¢ Python: ç¡®ä¿æœ‰ setup.py æˆ– pyproject.toml"""
        
        print(f"ğŸ“¦ æ‰“åŒ…å‘½ä»¤: {command}")
        
        # 4. æ‰§è¡Œæ‰“åŒ…
        print(f"âš™ï¸  æ‰§è¡Œä¸­...")
        executor = SmartExecutor()
        exec_result = executor.execute_with_monitoring(
            command=command,
            work_dir=work_dir,
            timeout=120,  # æ‰“åŒ…å¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´
            project_info=project_info
        )
        
        # 5. æ ¼å¼åŒ–ç»“æœ
        final_result = f"""{result_text}
ğŸ“¦ æ‰“åŒ…å‘½ä»¤: {command}

"""
        
        if exec_result["auto_install_triggered"]:
            install_cmd = CommandAnalyzer.analyze_install_command(project_info)
            final_result += f"""âš ï¸  æ£€æµ‹åˆ°ä¾èµ–æœªå®‰è£…
ğŸ“¥ è‡ªåŠ¨æ‰§è¡Œ: {install_cmd}
   âœ“ ä¾èµ–å®‰è£…å®Œæˆ

"""
        
        if exec_result["success"]:
            final_result += "ğŸ‰ é¡¹ç›®æ‰“åŒ…æˆåŠŸï¼\n"
            
            # å°è¯•æ£€æµ‹è¾“å‡ºç›®å½•
            common_build_dirs = ["dist", "build", "out", "public"]
            work_path = Path(work_dir)
            
            found_dirs = []
            for dir_name in common_build_dirs:
                dir_path = work_path / dir_name
                if dir_path.exists() and dir_path.is_dir():
                    found_dirs.append(dir_name)
            
            if found_dirs:
                final_result += f"   ğŸ“ è¾“å‡ºç›®å½•: {', '.join(found_dirs)}"
            
            if exec_result["output"]:
                # æ˜¾ç¤ºæœ€åå‡ è¡Œè¾“å‡º
                output_lines = exec_result["output"].split('\n')
                last_lines = output_lines[-3:] if len(output_lines) > 3 else output_lines
                if last_lines:
                    final_result += f"\n\nğŸ“‹ æ‰“åŒ…æ—¥å¿—:\n   " + "\n   ".join(last_lines)
        else:
            final_result += f"""âŒ é¡¹ç›®æ‰“åŒ…å¤±è´¥

é”™è¯¯ä¿¡æ¯:
{exec_result['error']}"""
        
        return final_result
        
    except Exception as e:
        return f"""âŒ é¡¹ç›®æ‰“åŒ…å¤±è´¥

æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {str(e)}"""


# åˆ›å»º LangChain Tool å®ä¾‹
start_project_tool = Tool(
    name="start_project",
    description="""æ™ºèƒ½å¯åŠ¨é¡¹ç›®ã€‚è‡ªåŠ¨æ£€æµ‹é¡¹ç›®ç±»å‹ï¼ˆNode.js/Pythonï¼‰ï¼Œåˆ†æå¯åŠ¨å‘½ä»¤ï¼Œåå°æ‰§è¡Œå¹¶ç›‘æ§è¾“å‡ºã€‚
    
åŠŸèƒ½ç‰¹æ€§:
â€¢ è‡ªåŠ¨æ£€æµ‹é¡¹ç›®ç±»å‹å’ŒåŒ…ç®¡ç†å™¨
â€¢ æ™ºèƒ½åˆ†æå¯åŠ¨å‘½ä»¤ï¼ˆdev/start/serve ç­‰ï¼‰
â€¢ å®æ—¶ç›‘æ§è¾“å‡ºï¼Œæå–ç«¯å£ä¿¡æ¯
â€¢ è‡ªåŠ¨å¤„ç†ä¾èµ–ç¼ºå¤±é—®é¢˜ï¼ˆè‡ªåŠ¨æ‰§è¡Œ installï¼‰
â€¢ æ”¯æŒé‡è¯•æœºåˆ¶

é€‚ç”¨åœºæ™¯:
â€¢ ç”¨æˆ·è¯´"å¯åŠ¨é¡¹ç›®"ã€"è¿è¡Œé¡¹ç›®"ã€"start project"
â€¢ ç”¨æˆ·æƒ³è¦å¯åŠ¨å¼€å‘æœåŠ¡å™¨
â€¢ ç”¨æˆ·éœ€è¦å¿«é€Ÿå¯åŠ¨æœ¬åœ°é¡¹ç›®

è¾“å…¥æ ¼å¼ï¼ˆå¯é€‰JSONï¼‰:
{"work_dir": "/path/to/project"}  # å¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨é…ç½®çš„å·¥ä½œç›®å½•

æ”¯æŒçš„é¡¹ç›®ç±»å‹:
â€¢ Node.js é¡¹ç›® (package.json + pnpm/npm/yarn)
â€¢ Python é¡¹ç›® (main.py/app.py + pip)""",
    func=start_project_tool_func
)

build_project_tool = Tool(
    name="build_project", 
    description="""æ™ºèƒ½æ‰“åŒ…é¡¹ç›®ã€‚è‡ªåŠ¨æ£€æµ‹é¡¹ç›®ç±»å‹ï¼Œåˆ†ææ‰“åŒ…å‘½ä»¤å¹¶æ‰§è¡Œã€‚

åŠŸèƒ½ç‰¹æ€§:
â€¢ è‡ªåŠ¨æ£€æµ‹é¡¹ç›®ç±»å‹å’ŒåŒ…ç®¡ç†å™¨
â€¢ æ™ºèƒ½åˆ†ææ‰“åŒ…å‘½ä»¤ï¼ˆbuild/bundle ç­‰ï¼‰
â€¢ ç›‘æ§æ‰“åŒ…è¿‡ç¨‹å’Œè¾“å‡º
â€¢ è‡ªåŠ¨å¤„ç†ä¾èµ–é—®é¢˜

é€‚ç”¨åœºæ™¯:
â€¢ ç”¨æˆ·è¯´"æ‰“åŒ…é¡¹ç›®"ã€"æ„å»ºé¡¹ç›®"ã€"build project"
â€¢ ç”¨æˆ·éœ€è¦ç”Ÿæˆç”Ÿäº§ç‰ˆæœ¬
â€¢ ç”¨æˆ·è¦å‘å¸ƒé¡¹ç›®

è¾“å…¥æ ¼å¼ï¼ˆå¯é€‰JSONï¼‰:
{"work_dir": "/path/to/project"}

æ”¯æŒçš„é¡¹ç›®ç±»å‹:
â€¢ Node.js é¡¹ç›® (package.json)
â€¢ Python é¡¹ç›® (setup.py/pyproject.toml)""",
    func=build_project_tool_func
)

# åˆ›å»ºé¡¹ç›®è¯Šæ–­å·¥å…·
diagnose_project_tool = Tool(
    name="diagnose_project",
    description="""è¯Šæ–­é¡¹ç›®è¿è¡ŒçŠ¶æ€ã€‚æ£€æŸ¥è¿›ç¨‹ã€ç«¯å£ã€è¿æ¥ç­‰çŠ¶æ€ã€‚

åŠŸèƒ½ç‰¹æ€§:
â€¢ æ£€æŸ¥è¿›ç¨‹æ˜¯å¦åœ¨è¿è¡Œ
â€¢ æ£€æŸ¥ç«¯å£æ˜¯å¦åœ¨ç›‘å¬
â€¢ æµ‹è¯•HTTPè¿æ¥æ˜¯å¦æ­£å¸¸
â€¢ æä¾›è¯¦ç»†çš„è¯Šæ–­æŠ¥å‘Šå’Œè§£å†³å»ºè®®

é€‚ç”¨åœºæ™¯:
â€¢ ç”¨æˆ·è¯´"è¯Šæ–­é¡¹ç›®"ã€"æ£€æŸ¥é¡¹ç›®çŠ¶æ€"ã€"é¡¹ç›®æ— æ³•è®¿é—®"
â€¢ é¡¹ç›®å¯åŠ¨åæ— æ³•æ­£å¸¸è®¿é—®
â€¢ æ’æŸ¥é¡¹ç›®è¿è¡Œé—®é¢˜

è¾“å…¥æ ¼å¼ï¼ˆå¯é€‰JSONï¼‰:
{"pid": "12345", "port": "3001"}  # æ£€æŸ¥æŒ‡å®šè¿›ç¨‹å’Œç«¯å£

æ”¯æŒçš„æ£€æŸ¥:
â€¢ è¿›ç¨‹çŠ¶æ€æ£€æŸ¥
â€¢ ç«¯å£ç›‘å¬æ£€æŸ¥  
â€¢ HTTPè¿æ¥æµ‹è¯•
â€¢ é—®é¢˜è¯Šæ–­å’Œå»ºè®®""",
    func=diagnose_project_tool_func
)

# åˆ›å»ºåœæ­¢é¡¹ç›®å·¥å…·
stop_project_tool = Tool(
    name="stop_project",
    description="""åœæ­¢è¿è¡Œä¸­çš„é¡¹ç›®ã€‚å¯ä»¥åœæ­¢å¼€å‘æœåŠ¡å™¨ã€æ„å»ºè¿›ç¨‹ç­‰ã€‚

åŠŸèƒ½ç‰¹æ€§:
â€¢ è‡ªåŠ¨æŸ¥æ‰¾å¸¸è§ç«¯å£çš„è¿›ç¨‹ï¼ˆ3000, 8000, 5173ç­‰ï¼‰
â€¢ æ”¯æŒæŒ‡å®šç«¯å£æˆ–è¿›ç¨‹IDåœæ­¢
â€¢ æ™ºèƒ½è¿›ç¨‹ç®¡ç†å’Œæ¸…ç†

é€‚ç”¨åœºæ™¯:
â€¢ ç”¨æˆ·è¯´"åœæ­¢é¡¹ç›®"ã€"å…³é—­æœåŠ¡å™¨"ã€"stop project"
â€¢ éœ€è¦é‡Šæ”¾ç«¯å£æˆ–åœæ­¢å¼€å‘æœåŠ¡å™¨
â€¢ æ¸…ç†åå°è¿è¡Œçš„é¡¹ç›®è¿›ç¨‹

è¾“å…¥æ ¼å¼ï¼ˆå¯é€‰JSONï¼‰:
{"port": "3000"}     # åœæ­¢æŒ‡å®šç«¯å£çš„è¿›ç¨‹
{"pid": "12345"}     # åœæ­¢æŒ‡å®šè¿›ç¨‹ID

æ”¯æŒçš„æ“ä½œ:
â€¢ è‡ªåŠ¨åœæ­¢å¸¸è§å¼€å‘ç«¯å£çš„è¿›ç¨‹
â€¢ æŒ‡å®šç«¯å£åœæ­¢
â€¢ æŒ‡å®šè¿›ç¨‹IDåœæ­¢""",
    func=stop_project_tool_func
)

# å¯¼å‡ºå·¥å…·åˆ—è¡¨
project_manager_tools = [start_project_tool, build_project_tool, diagnose_project_tool, stop_project_tool]
